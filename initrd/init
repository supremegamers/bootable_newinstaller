#!/bin/busybox sh
#
# By Chih-Wei Huang <cwhuang@linux.org.tw>
# and Thorsten Glaser <tg@mirbsd.org>
#
# Last updated 2018/01/26
#
# License: GNU Public License
# We explicitely grant the right to use the scripts
# with Android-x86 project.
#

PATH=/sbin:/bin:/system/bin:/system/xbin; export PATH

# auto installation
[ -n "$AUTO_INSTALL" ] && INSTALL=1

# configure debugging output
if [ -n "$DEBUG" -o -n "$INSTALL" ]; then
	LOG=/tmp/log
	set -x
else
	LOG=/dev/null
	test -e "$LOG" || busybox mknod $LOG c 1 3
fi
exec 2>> $LOG

chmod 755 /sbin/mount.ntfs-3g
chmod 755 /sbin/grub
chmod 755 /sbin/mkntfs
chmod 755 /sbin/efibootmgr

# early boot
if test x"$HAS_CTTY" != x"Yes"; then
	# initialise /proc and /sys
	busybox mount -t proc proc /proc
	busybox mount -t sysfs sys /sys
	# let busybox install all applets as symlinks
	busybox --install -s
	# spawn shells on tty 2 and 3 if debug or installer
	if test -n "$DEBUG" || test -n "$INSTALL"; then
		# ensure they can open a controlling tty
		mknod /dev/tty c 5 0
		# create device nodes then spawn on them
		mknod /dev/tty2 c 4 2 && openvt
		mknod /dev/tty3 c 4 3 && openvt
	fi
	if test -z "$DEBUG" || test -n "$INSTALL"; then
		echo 0 0 0 0 > /proc/sys/kernel/printk
	fi
	# initialise /dev (first time)
	mkdir -p /dev/block
	echo /sbin/mdev > /proc/sys/kernel/hotplug
	mdev -s
	# re-run this script with a controlling tty
	exec env HAS_CTTY=Yes setsid cttyhack /bin/sh "$0" "$@"
fi

# now running under a controlling tty; debug output from stderr into log file
# boot up Android

error()
{
	echo $*
	return 1
}

try_mount()
{
	RW=$1; shift
	if [ "${ROOT#*:/}" != "$ROOT" ]; then
		# for NFS roots, use nolock to avoid dependency to portmapper
		mount -o $RW,noatime,nolock $@
		return $?
	fi
	case $(blkid $1) in
		*TYPE=*ntfs*)
			mount.ntfs-3g -o rw,force $@
			;;
		*TYPE=*)
			mount -o $RW,noatime $@
			;;
		*)
			return 1
			;;
	esac
}

extract_magisk_apk(){



mkdir -p "$TMPDIR/magisk32"
mkdir -p "$TMPDIR/magisk"
 

unzip -o "$APKFILE" "lib/x86_64/*" -d "$TMPDIR/magisk" &>/dev/null
chmod -R 777 "$TMPDIR/magisk"
unzip -o "$APKFILE" "lib/x86/*" -d "$TMPDIR/magisk32" &>/dev/null
chmod -R 777 "$TMPDIR/magisk32"


unzip -o "$APKFILE" 'assets/*' -x 'assets/chromeos/*' -d "$MAGISKCORE" &>/dev/null

}


random_str(){
local FROM
local TO
FROM="$1"; TO="$2"
tr -dc A-Za-z0-9 </dev/urandom | head -c $(($FROM+$(($RANDOM%$(($TO-$FROM+1))))))
}


magisk_loader(){


magisk_postfsdata=`random_str 6 15`
magisk_service=`random_str 6 15`
magisk_boot_complete=`random_str 6 15`

dev_random=`random_str 7 10`


# always use "/dev/<random_string>" as magisk tmpfs

     MAGISKTMP="/dev/$dev_random"
     mount_sbin="mkdir -p \"$MAGISKTMP\"
mnt_tmpfs \"$MAGISKTMP\"
chmod 755 \"$MAGISKTMP\""
     umount_sbin="umount /sbin"


RM_RUSTY_MAGISK="#remove rusty-magisk gearlock module to make sure it is not conflicted with our magisk implement
              rm /data/ghome/gearboot/overlay/rusty-magisk/init/init.superuser.rc
              rm /data/.rusty-magisk/magisk.apk
              rm /data/.rusty-magisk/magisk
              rm /data/ghome/.local/bin/rusty-magisk"

ADDITIONAL_SCRIPT="( # addition script
rm -rf /data/adb/post-fs-data.d/fix_mirror_mount.sh
rm -rf /data/adb/service.d/fix_modules_not_show.sh


echo \"
export PATH=\\\"\$MAGISKTMP:\\\$PATH\\\"

set -x
exec 2>>\\\"\$MAGISKTMP/emu/record_logs.txt\\\"

# prevent /system/bin/su from removing

if mount | grep -q \\\" /system/bin \\\" && [ -f \\\"/system/bin/magisk\\\" ]; then
    umount -l /system/bin/su
    rm -rf /system/bin/su
    ln -fs ./magisk /system/bin/su
    mount -o ro,remount /system/bin
    umount -l /system/bin/magisk
    mount --bind \\\"\$MAGISKTMP/magisk\\\" /system/bin/magisk
fi

# install magisk app


sleep 1
MAGISK_STUB=\\\$(strings /data/adb/magisk.db | grep -oE 'requester..*' | cut -c10-)
if [ ! -z \\\"\\\$MAGISK_STUB\\\" ]; then
/system/bin/pm path \\\"\\\$MAGISK_STUB\\\" || /system/bin/pm install \\\"\$MAGISKTMP/magisk.apk\\\"
else
/system/bin/pm install \\\"\$MAGISKTMP/magisk.apk\\\"
fi

\" >\$MAGISKTMP/emu/magisksu_survival.sh

# workaround unseperate data partition

echo \"
SCRIPT=\\\"\\\$0\\\"
MAGISKTMP=\\\$(magisk --path) || MAGISKTMP=/sbin
set -x
exec 2>>\\\"\\\$MAGISKTMP/emu/record_logs.txt\\\"
( #fix mount data mirror
function cmdline() { 
	awk -F\\\"\\\${1}=\\\" '{print \\\$2}' < /proc/cmdline | cut -d' ' -f1 2> /dev/null
}

SRC=\\\"\\\$(cmdline SRC)\\\"
BIPATH=\\\"\\\$(cmdline BOOT_IMAGE)\\\"
DATA=\\\"\\\$(cmdline DATA)\\\"
test -z \\\"\\\$SRC\\\" && SRC=\\\"\\\${BIPATH%/*}\\\"
test -z \\\"\\\$SRC\\\" && exit
test -z \\\"\\\$DATA\\\" && DATA=data

inode_data1=\\\$(ls -id \\\"\\\$MAGISKTMP/.magisk/mirror/data/\\\$SRC/\\\$DATA\\\" | awk '{ print \\\$1 }')
inode_data2=\\\$(ls -id \\\"\\\$MAGISKTMP/.magisk/mirror/data/\\\$SRC/data\\\" | awk '{ print \\\$1 }')
inode_data=\\\$(ls -id \\\"/data\\\" | awk '{ print \\\$1 }')

if [ \\\"\\\$inode_data1\\\" == \\\"\\\$inode_data\\\" ]; then
mount --bind \\\"\\\$MAGISKTMP/.magisk/mirror/data/\\\$SRC/\\\$DATA\\\" \\\"\\\$MAGISKTMP/.magisk/mirror/data\\\"
elif [ \\\"\\\$inode_data2\\\" == \\\"\\\$inode_data\\\" ]; then
mount --bind \\\"\\\$MAGISKTMP/.magisk/mirror/data/\\\$SRC/data\\\" \\\"\\\$MAGISKTMP/.magisk/mirror/data\\\"
fi )
rm -rf \\\"\\\$SCRIPT\\\"
\" >/data/adb/post-fs-data.d/fix_mirror_mount.sh
echo \"
SCRIPT=\\\"\\\$0\\\"
MAGISKTMP=\\\$(magisk --path) || MAGISKTMP=/sbin
set -x
exec 2>>\\\"\\\$MAGISKTMP/emu/record_logs.txt\\\"
inode_data1=\\\$(ls -id \\\"\\\$MAGISKTMP/.magisk/mirror/data/adb/modules\\\" | awk '{ print \\\$1 }')
inode_data2=\\\$(ls -id \\\"\\\$MAGISKTMP/.magisk/modules\\\" | awk '{ print \\\$1 }')
inode_data=\\\$(ls -id \\\"/data/adb/modules\\\" | awk '{ print \\\$1 }')

if [ \\\"\\\$inode_data2\\\" != \\\"\\\$inode_data\\\" ]; then
  if [ \\\"\\\$inode_data1\\\" == \\\"\\\$inode_data\\\" ]; then
    mount --bind \\\"\\\$MAGISKTMP/.magisk/mirror/data/adb/modules\\\" \\\"\\\$MAGISKTMP/.magisk/modules\\\"
  fi
fi


rm -rf \\\"\\\$SCRIPT\\\"\" >/data/adb/service.d/fix_modules_not_show.sh
chmod 755 /data/adb/service.d/fix_modules_not_show.sh
chmod 755 /data/adb/post-fs-data.d/fix_mirror_mount.sh; )"


EXPORT_PATH="export PATH /sbin:/system/bin:/system/xbin:/vendor/bin:/gearlock/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin"


magiskloader="
              

          on post-fs-data
$RM_RUSTY_MAGISK
              start logd
              start adbd
              rm /dev/.magisk_unblock
              copy $MAGISKBASE/overlay.sh /dev/magisk_overlay.sh
              exec u:r:su:s0 root root -- $MAGISKBASE/busybox sh -o standalone /dev/magisk_overlay.sh
              rm /dev/magisk_overlay.sh
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk --daemon
              start $magisk_postfsdata
              # wait all magisk post-fs-data jobs are completed or 40s  has passed
              wait /dev/.magisk_unblock 40
              rm /dev/.magisk_unblock

          service $magisk_postfsdata $MAGISKTMP/magisk --post-fs-data
              user root
              seclabel u:r:magisk:s0
              oneshot

          service $magisk_service $MAGISKTMP/magisk --service
              class late_start
              user root
              seclabel u:r:magisk:s0
              oneshot

          on property:sys.boot_completed=1
              start $magisk_boot_complete
# remove magisk service traces from some detection
# although detect modified init.rc is not always correct
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk resetprop --delete init.svc.$magisk_postfsdata
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk resetprop --delete init.svc.$magisk_service
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk resetprop --delete init.svc.$magisk_boot_complete
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk resetprop --delete init.svc_debug_pid.$magisk_postfsdata
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk resetprop --delete init.svc_debug_pid.$magisk_service
              exec u:r:magisk:s0 root root -- $MAGISKTMP/magisk resetprop --delete init.svc_debug_pid.$magisk_boot_complete
              exec_background u:r:magisk:s0 root root -- $MAGISKTMP/busybox sh -o standalone $MAGISKTMP/emu/magisksu_survival.sh
          service $magisk_boot_complete $MAGISKTMP/magisk --boot-complete
              user root
              seclabel u:r:magisk:s0
              oneshot"


overlay_loader="#!$MAGISKBASE/busybox sh

export PATH=/sbin:/system/bin:/system/xbin


mnt_tmpfs(){ (
# MOUNT TMPFS ON A DIRECTORY
MOUNTPOINT=\"\$1\"
mkdir -p \"\$MOUNTPOINT\"
mount -t tmpfs -o \"mode=0755\" tmpfs \"\$MOUNTPOINT\" 2>/dev/null
) }



mnt_bind(){ (
# SHORTCUT BY BIND MOUNT
FROM=\"\$1\"; TO=\"\$2\"
if [ -L \"\$FROM\" ]; then
SOFTLN=\"\$(readlink \"\$FROM\")\"
ln -s \"\$SOFTLN\" \"\$TO\"
elif [ -d \"\$FROM\" ]; then
mkdir -p \"\$TO\" 2>/dev/null
mount --bind \"\$FROM\" \"\$TO\"
else
echo -n 2>/dev/null >\"\$TO\"
mount --bind \"\$FROM\" \"\$TO\"
fi
) }

revert_changes(){
#remount system read-only to fix Magisk fail to mount mirror

if mount -t rootfs | grep -q \" / \" || mount -t tmpfs | grep -q \" / \"; then
rm -rf /magisk
fi


mount -o ro,remount /
mount -o ro,remount /system
mount -o ro,remount /vendor
mount -o ro,remount /product
mount -o ro,remount /system_ext

# unmount patched files

umount -l /system/etc/init
umount -l /init.rc
umount -l /system/etc/init/hw/init.rc
umount -l /sepolicy
umount -l /system/vendor/etc/selinux/precompiled_sepolicy
}


exit_magisk(){
umount -l $MAGISKTMP
revert_changes
echo -n >/dev/.magisk_unblock
}


API=\$(getprop ro.build.version.sdk)
  ABI=\$(getprop ro.product.cpu.abi)
  if [ \"\$ABI\" = \"x86\" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ \"\$ABI\" = \"arm64-v8a\" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ \"\$ABI\" = \"x86_64\" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi

magisk_name=\"magisk32\"
[ \"\$IS64BIT\" == true ] && magisk_name=\"magisk64\"

# umount previous /sbin tmpfs overlay

count=0
( magisk --stop ) &

# force umount /sbin tmpfs

until ! mount | grep -q \" /sbin \"; do
[ "$count" -gt "10" ] && break
umount -l /sbin 2>/dev/null
sleep 0.1
count=$(($count+1))
test ! -d /sbin && break
done

# mount magisk tmpfs path

$mount_sbin

MAGISKTMP=$MAGISKTMP
chmod 755 \"\$MAGISKTMP\"
set -x
mkdir -p \$MAGISKTMP/.magisk
mkdir -p \$MAGISKTMP/emu
exec 2>>\$MAGISKTMP/emu/record_logs.txt
exec >>\$MAGISKTMP/emu/record_logs.txt

cd $MAGISKBASE 

test ! -f \"./\$magisk_name\" && magisk_name=magisk32
test ! -f \"./\$magisk_name\" && { echo -n >/dev/.overlay_unblock; exit_magisk; exit 0; }


MAGISKBIN=/data/adb/magisk
mkdir /data/unencrypted
for mdir in modules post-fs-data.d service.d magisk; do
test ! -d /data/adb/\$mdir && rm -rf /data/adb/\$mdir
mkdir /data/adb/\$mdir 2>/dev/null
done
for file in magisk32 magisk64 magiskinit magiskpolicy; do
  cp -af ./\$file \$MAGISKTMP/\$file 2>/dev/null
  chmod 755 \$MAGISKTMP/\$file
  cp -af ./\$file \$MAGISKBIN/\$file 2>/dev/null
  chmod 755 \$MAGISKBIN/\$file
done
cp -af ./magiskboot \$MAGISKBIN/magiskboot
cp -af ./magisk.apk \$MAGISKTMP/magisk.apk
ln \$MAGISKTMP/magisk.apk \$MAGISKTMP/stub.apk
cp -af ./busybox \$MAGISKBIN/busybox
cp -af ./busybox \$MAGISKTMP
chmod 755 \$MAGISKTMP/busybox
\$MAGISKTMP/busybox --install -s \$MAGISKTMP
cp -af ./assets/* \$MAGISKBIN

# create symlink / applet

ln -s ./\$magisk_name \$MAGISKTMP/magisk 2>/dev/null
ln -s ./magisk \$MAGISKTMP/su 2>/dev/null
ln -s ./magisk \$MAGISKTMP/resetprop 2>/dev/null
ln -s ./magisk \$MAGISKTMP/magiskhide 2>/dev/null
[ ! -f \"\$MAGISKTMP/magiskpolicy\" ] && ln -s ./magiskinit \$MAGISKTMP/magiskpolicy 2>/dev/null
ln -s ./magiskpolicy \$MAGISKTMP/supolicy 2>/dev/null

mkdir -p \$MAGISKTMP/.magisk/mirror
mkdir \$MAGISKTMP/.magisk/block
touch \$MAGISKTMP/.magisk/config

restorecon -R /data/adb/magisk

$ADDITIONAL_SCRIPT

[ ! -f \"\$MAGISKTMP/magisk\" ] && exit_magisk

revert_changes

"
}





check_root()
{
	if [ "`dirname $1`" = "/dev" ]; then
		[ -e $1 ] || return 1
		blk=`basename $1`
		[ ! -e /dev/block/$blk ] && ln $1 /dev/block
		dev=/dev/block/$blk
	else
		dev=$1
	fi
	try_mount ro $dev /mnt || return 1
	if [ -n "$iso" -a -e /mnt/$iso ]; then
		mount --move /mnt /iso
		mkdir /mnt/iso
		mount -o loop /iso/$iso /mnt/iso
	fi
  INITRD_REAL=initrd_real.img
  APKFILE=/mnt/$SRC/magisk.apk
  echo "$dev" >"$MAGISKCORE/config"
	if [ -e /mnt/$SRC/$INITRD_REAL ]; then
		zcat /mnt/$SRC/$INITRD_REAL | cpio -id > /dev/null
  elif [ -e /mnt/$SRC/initrd.img ]; then
    zcat /mnt/$SRC/initrd.img | cpio -id > /dev/null
	elif [ -b /dev/$INITRD_REAL ]; then
		zcat /dev/$INITRD_REAL | cpio -id > /dev/null
	else
		return 1
	fi
}

remount_rw()
{
	# "foo" as mount source is given to workaround a Busybox bug with NFS
	# - as it's ignored anyways it shouldn't harm for other filesystems.
	mount -o remount,rw foo /mnt
}

warn_no_magisk(){
echo "WARNING: Cannot find magisk.apk"
echo "Boot Android with no Magisk"
sleep 1
}


debug_shell()
{
	if [ -x system/bin/sh ]; then
		echo Running MirBSD Korn Shell...
		USER="($1)" system/bin/sh -l 2>&1
	else
		echo Running busybox ash...
		sh 2>&1
	fi
}

abort(){
echo "$1"
sleep 5
exit 1
}



init_magisk(){

. /bin/utils.sh
. /bin/info.sh


( # disable magisk with flag FIXFS

if [ "$FIXFS" == "1" ]; then
    echo "Disable all Magisk modules"
    mkdir /data
    mount_data_part /data
    for magisk_module in $(ls /data/adb/modules); do
        echo -n >/data/adb/modules/$magisk_module/disable
    done
    umount -l /data
fi
)


MAGISKBASE=MAGISK_FILES_BASE
APKFILE="$MAGISKCORE/magisk.apk"

rm -rf /scripts/*magisk*
if [ -f "$APKFILE" ]; then
cp /bin/magisk.sh /scripts/99_magisk
mkdir -p "$MAGISKCORE"
extract_magisk_apk
magisk_loader
rm -rf "/magisk/magisk.rc"
echo "$magiskloader" >>"/magisk/magisk.rc"
rm -rf "/magisk/overlay.sh"
echo "$overlay_loader" >"/magisk/overlay.sh"
else
warn_no_magisk
rm -rf /scripts/99_magisk
fi


# continue boot

exec /init_2
}

init_magisk

